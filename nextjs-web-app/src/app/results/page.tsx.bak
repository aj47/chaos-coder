"use client";

import { useSearchParams } from "next/navigation";
import { useState, useEffect, Suspense } from "react";
import Link from "next/link";
import { motion } from "framer-motion";
import { AuroraBackground } from "@/components/ui/aurora-background";
import AppTile from "@/components/AppTile";
import CodePreviewPanel from "@/components/CodePreviewPanel";
import { BrowserContainer } from "@/components/ui/browser-container";
import { useTheme } from "@/context/ThemeContext";
import PromptInput from "@/components/DevTools/PromptInput";
import PerformanceMetrics from "@/components/DevTools/PerformanceMetrics";
import VoiceInput from "@/components/DevTools/VoiceInput";
import MockDeployButton from "@/components/MockDeployButton";
import { SignupModal } from "@/components/SignupModal";
import styled from "styled-components";
import { MoveRight } from "lucide-react";

const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 400px;
  width: 100%;
  gap: 20px;
  color: #9ca3af;
`;

const LoadingTitle = styled.div`
  font-size: 24px;
  margin-bottom: 10px;
`;

const LoadingBar = styled(motion.div)`
  width: 100%;
  max-width: 500px;
  height: 8px;
  background: rgba(75, 85, 99, 0.3);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
`;

const LoadingProgress = styled(motion.div)`
  height: 100%;
  background: #4b5563;
  border-radius: 4px;
`;

const ShortLoadingBar = styled(LoadingBar)`
  max-width: 300px;
`;

// Wrapper component that uses searchParams
function ResultsContent() {
  const NUM_APPS = 9; // Single variable to control number of apps
  
  const searchParams = useSearchParams();
  const [loadingStates, setLoadingStates] = useState<boolean[]>(
    new Array(NUM_APPS).fill(true)
  );
  const [results, setResults] = useState<string[]>(new Array(NUM_APPS).fill(""));
  const [error, setError] = useState<string | null>(null);
  const [selectedAppIndex, setSelectedAppIndex] = useState(0);
  const [editedResults, setEditedResults] = useState<string[]>(
    new Array(NUM_APPS).fill("")
  );
  const [isPromptOpen, setIsPromptOpen] = useState(false);
  const [isMetricsOpen, setIsMetricsOpen] = useState(false);
  const [generationTimes, setGenerationTimes] = useState<{
    [key: number]: number;
  }>({});
  const [isVoiceEnabled, setIsVoiceEnabled] = useState(true);
  const [showSignupModal, setShowSignupModal] = useState(false);
  const { theme } = useTheme();

  const variations = [
    "",
    "Make it visually appealing and use a different framework than the other versions.",
    "Focus on simplicity and performance. Use minimal dependencies.",
    "Add some creative features that might not be explicitly mentioned in the prompt.",
    "Create an enhanced version with additional features and modern design patterns.",
    "Build a version with accessibility and internationalization features in mind.",
    "Create a version optimized for mobile devices with responsive design.",
    "Build a version with advanced animations and interactive elements.",
    "Create a version with data visualization capabilities.",
    "Build a version with offline functionality and progressive web app features.",
  ];

  const appTitles = [
    "Standard Version",
    "Visual Focus",
    "Minimalist Version",
    "Creative Approach",
    "Enhanced Version",
    "Accessible Version",
    "Mobile Optimized",
    "Interactive Version",
    "Data Visualization",
    "Progressive Web App",
  ];

  // Handle keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.shiftKey) {
        switch (e.key.toLowerCase()) {
          case "l":
            e.preventDefault();
            setIsPromptOpen((prev) => !prev);
            break;
          case "p":
          case "x":
            e.preventDefault();
            setIsMetricsOpen((prev) => !prev);
            break;
        }
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  const generateApp = async (index: number, promptText: string) => {
    const startTime = performance.now();
    try {
      const framework =
        appTitles[index] === "Standard Version"
          ? "bootstrap"
          : appTitles[index] === "Visual Focus"
          ? "materialize"
          : appTitles[index] === "Minimalist Version"
          ? "pure"
          : appTitles[index] === "Creative Approach"
          ? "tailwind"
          : appTitles[index] === "Accessible Version"
          ? "foundation"
          : "Bulma";

      const response = await fetch("/api/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: promptText,
          variation: variations[index],
          framework,
        }),
      });

      if (response.status === 429) {
        // Show signup modal for rate limit
        setShowSignupModal(true);
        throw new Error("Rate limit exceeded. Please create an account to continue.");
      }

      if (!response.ok) {
        throw new Error(`Failed to generate app ${index + 1}`);
      }

      const data = await response.json();
      if (data.error === "rate_limit_exceeded") {
        setShowSignupModal(true);
        throw new Error("Rate limit exceeded. Please create an account to continue.");
      } else if (data.error) {
        throw new Error(data.error);
      }

      setResults((prev) => {
        const newResults = [...prev];
        newResults[index] = data.code;
        return newResults;
      });

      setEditedResults((prev) => {
        const newResults = [...prev];
        newResults[index] = data.code;
        return newResults;
      });

      const endTime = performance.now();
      setGenerationTimes((prev) => ({
        ...prev,
        [index]: (endTime - startTime) / 1000, // Convert to seconds
      }));
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to generate applications"
      );
    } finally {
      setLoadingStates((prev) => {
        const newStates = [...prev];
        newStates[index] = false;
        return newStates;
      });
    }
  };

  const handleNewPrompt = async (prompt: string, isUpdate: boolean = false, chaosMode: boolean = false) => {
    if (isUpdate) {
      if (chaosMode) {
        // Update all apps in chaos mode
        setLoadingStates(new Array(6).fill(true));
        
        try {
          // Create an array of promises for all apps
          const updatePromises = appTitles.map(async (title, index) => {
            const framework =
              title === "Standard Version"
                ? "bootstrap"
                : title === "Visual Focus"
                ? "materialize"
                : title === "Minimalist Version"
                ? "pure"
                : title === "Creative Approach"
                ? "tailwind"
                : title === "Accessible Version"
                ? "foundation"
                : "Bulma";

            const response = await fetch("/api/generate", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                prompt,
                existingCode: editedResults[index],
                framework,
                isUpdate: true,
              }),
            });

            if (!response.ok) {
              throw new Error(`Failed to update app ${index + 1}`);
            }

            const data = await response.json();
            if (data.error) {
              throw new Error(data.error);
            }

            return { index, code: data.code };
          });

          // Wait for all updates to complete
          const results = await Promise.all(updatePromises);
          
          // Update all results at once
          setEditedResults((prev) => {
            const newResults = [...prev];
            results.forEach(result => {
              newResults[result.index] = result.code;
            });
            return newResults;
          });
        } catch (err) {
          setError(
            err instanceof Error ? err.message : "Failed to update applications in chaos mode"
          );
        } finally {
          setLoadingStates(new Array(6).fill(false));
        }
      } else {
        // Update only the selected app (original behavior)
        setLoadingStates((prev) => {
          const newStates = [...prev];
          newStates[selectedAppIndex] = true;
          return newStates;
        });

        try {
          const framework =
            appTitles[selectedAppIndex] === "Standard Version"
              ? "bootstrap"
              : appTitles[selectedAppIndex] === "Visual Focus"
              ? "materialize"
              : appTitles[selectedAppIndex] === "Minimalist Version"
              ? "pure"
              : appTitles[selectedAppIndex] === "Creative Approach"
              ? "tailwind"
              : appTitles[selectedAppIndex] === "Accessible Version"
              ? "foundation"
              : "Bulma";

          const response = await fetch("/api/generate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              prompt,
              existingCode: editedResults[selectedAppIndex],
              framework,
              isUpdate: true,
            }),
          });

          if (!response.ok) {
            throw new Error(`Failed to update app ${selectedAppIndex + 1}`);
          }

          const data = await response.json();
          if (data.error) {
            throw new Error(data.error);
          }

          setEditedResults((prev) => {
            const newResults = [...prev];
            newResults[selectedAppIndex] = data.code;
            return newResults;
          });
        } catch (err) {
          setError(
            err instanceof Error ? err.message : "Failed to update application"
          );
        } finally {
          setLoadingStates((prev) => {
            const newStates = [...prev];
            newStates[selectedAppIndex] = false;
            return newStates;
          });
        }
      }
    } else {
      setLoadingStates(new Array(NUM_APPS).fill(true));
      setResults(new Array(NUM_APPS).fill(""));
      setEditedResults(new Array(NUM_APPS).fill(""));
      setGenerationTimes({});
      Promise.all(variations.map((_, index) => generateApp(index, prompt)));
    }
  };

  const handleVoiceInput = (text: string) => {
    handleNewPrompt(text, true, false); // Default to single mode for voice input
  };

  useEffect(() => {
    const prompt = searchParams.get("prompt");
    if (!prompt) {
      setError("No prompt provided");
      setLoadingStates(new Array(NUM_APPS).fill(false));
      return;
    }

    // Generate all apps in parallel
    Promise.all(variations.map((_, index) => generateApp(index, prompt)));
  }, [searchParams]);

  const handleCodeChange = (newCode: string) => {
    const newResults = [...editedResults];
    newResults[selectedAppIndex] = newCode;
    setEditedResults(newResults);
  };

  // Function to handle clicking on a tile
  const handleTileClick = (index: number) => {
    setSelectedAppIndex(index);
    // Scroll to the detailed view
    setTimeout(() => {
      document.getElementById('detailed-view')?.scrollIntoView({ 
        behavior: 'smooth',
        block: 'start'
      });
    }, 100);
  };

  return (
    <AuroraBackground>
      {showSignupModal && (
        <SignupModal
          isOpen={showSignupModal}
          onClose={() => setShowSignupModal(false)}
        />
      )}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.5 }}
        className={`w-full h-screen p-6 pb-20 md:p-8 ${
          theme === "dark" ? "bg-gray-900" : ""
        }`}
      >
        <div
          className={`